from abc import *
from typing import *
import numpy as np #type: ignore
import sympy as sp #type: ignore
import matplotlib.pyplot as plt #type: ignore
from tqdm import tqdm #type: ignore
from WHyperbolic import *


sp.init_printing(unicode = True)



class Iteration(Generic[X]):
    def __init__(self, space: WHyperbolicSpace[X], initial: Optional[X] = None, operator: Optional[Callable[[X, int], X]] = None):
        self._space = space
        self._initial: Optional[X] = initial
        self._operator = operator
        if initial is not None:
            self._computed_values = [self._initial]
        self._computed_as_reg_err: List[float] = []
        self._computed_as_reg_to_op_err: List[float] = []
        self._computed_steps_until_as_reg_err: List[int] = []
        self._computed_steps_until_as_reg_to_op_err: List[int] = []

    @abstractmethod
    def update(self, curr: X, step: int) -> X:
        ...

    def reset_computed(self, new_initial):
        self._computed_values = [new_initial]
        self._computed_as_reg_err = []
        self._computed_as_reg_to_op_err = []
        self._computed_steps_until_as_reg_err = []
        self._computed_steps_until_as_reg_to_op_err = []

    @property
    def initial(self): 
        return self._initial 

    @initial.setter 
    def initial(self, value):
        self._initial = value 
        self.reset_computed(self._initial)


    # Returns the `index`-th value generated by the iteration.
    # Previously computed values are stored so that `iter[n]` is computed in `max(1, n - the largest m such that iter[m] has already been computed)` steps. 
    def __getitem__(self, index):
        if index == 0:
            return self._initial
        if index < len(self._computed_values):
            return self._computed_values[index]
        else:
            curr = self._computed_values[-1]
            prev = curr
            for i in range(len(self._computed_values), index + 1):
                curr = self.update(prev, i)
                self._computed_values += [curr]
                prev = curr 
            return curr


    def check_runnable(self) -> bool:
        return self._initial is not None

    # TODO: add memoization
    def as_reg(self, index):
        return self._space.dist(self[index], self[index + 1])

    # TODO: add memoization
    def as_reg_to_op(self, index):
        return self._space.dist(self[index], self._operator(self[index], index))


    def get_as_reg_errs(self, steps):
        return [self.as_reg(i) for i in range(0, steps)]


    def get_as_reg_to_op_errs(self, steps):
        return [self.as_reg_to_op(i) for i in range(0, steps)]


    # Computes the least `i` such `dist(self[i], self[i + 1]) <= epsilon`
    # TODO: add memoization. 
    def steps_until_as_reg_err(self, epsilon: float) -> int:
        i = 0
        while self.as_reg(i) > epsilon:
            i += 1
        return i

    # Computes the least `i` such `dist(self[i], operator(self[i])) <= epsilon`
    # TODO: add memoization
    def steps_until_as_reg_to_op_err(self, epsilon: float) -> int:
        i = 0
        while self.as_reg_to_op(i) > epsilon:
            i += 1 
        return i

    # The method is currently slow (quadratic). After memoization is added, it will be much faster (linear)
    def get_steps_until_as_reg_errs(self, steps: int):
        return [self.steps_until_as_reg_err(1./(i + 1)) for i in tqdm(range(0, steps))]

    # The method is currently slow (quadratic). After memoization is added, it will be much faster (linear)
    def get_steps_until_as_reg_to_op_errs(self, steps: int):
        return [self.steps_until_as_reg_to_op_err(1./(i + 1)) for i in tqdm(range(0, steps))]
    
    


class Mann(Iteration):
    def __init__(self, space, parameters: Callable[[int], float], operator: Callable[[X], X], initial: X):
        Iteration.__init__(self, 
            space = space, 
            operator = lambda x, n: operator(x), 
            initial = initial
        )
        self.parameters = parameters

    def update(self, curr, step):
        return self._space.W(curr, self._operator(curr, 0), self.parameters(step))


class Halpern(Iteration):
    def __init__(self, space, parameters: Callable[[int], float], anchor: X, operator: Callable[[X], X], initial: X):
        Iteration.__init__(self, 
            space = space,
            operator = lambda x, n: operator(x),
            initial = initial
        )
        self.parameters = parameters
        self.anchor = anchor 

    def update(self, curr, step):
        return self._space.W(self.anchor, self._operator(curr, 0), self.parameters(step))


class TikhonovMann(Iteration):
    def __init__(self, space, parameters1, parameters2, origin, operator, initial):
        Iteration.__init__(self,
        space = space,
        operator = lambda x, n: operator(x),
        initial = initial,    
        )
        self.parameters1 = parameters1
        self.parameters2 = parameters2
        self.origin = origin

    def update(self, curr, step):
        interior = self._space.W(self.origin, curr, self.parameters1(step))
        return self._space.W(interior, self._operator(interior, 0), self.parameters2(step))